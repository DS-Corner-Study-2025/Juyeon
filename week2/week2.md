명시적 형 변환 
-> parseInt는 숫자+문자 문자열을 숫자로 변환
->숫자열을 문자열로 변환

반복문 종료시 break 와 continue 차이
break는 반복 강제 종료 
contiue는 반복 종료가 아닌 다음 반복 과정으로 점프

함수 
-> 유사하게 동작하는  중복 코드를 하나로 묶은 것
-> function 이라는 키워드로 함수 선언 ; 표현식으로도 선언 가능 
-> 반환 ; return문 사용해 함수 값 반환
-> 함수를 변수에 저장할 때에는 함수 호출과 달리 소괄호 명시x

 호이스킹
 -> js만의 독특한 기능 
 ; 변수,함수 호출 또는 접근 코드가 함수 선언 위에 있음에도 선언 코드가 위에 있는 것처럼 동작 
 => 함수 선언 전에 함수 호출 먼저 가능
 **표현식으로 저장한 함수는 선언이 아닌 값으로 취급되어 호이스팅 불가

 콜백함수
 ->함수가 다른 함수의 값으로 전달되는 것
   왜 필요? 
   함수가 동일한 기능을 갖더라도 특정 부분은 다르므로  새 함수를 만들게 되면 중복 코드가 발생,
   콜백 함수를 사용해 하나의 함수가 여러 동작을 수행하게 함.
 화살표 함수
 ->익명 함수를 간결하게 작성시 사용 / 함수 표현식의 단축 문법

스코프
-> js의 변수와 함수는 생성과 동시에 접근하거나 호출할 때  일정한 제약 갖음 이를 스코프라 칭함
-> 스코프는 변수나 함수의 제약 범위
 전역 스코프 -전역 변수 ; 코드 어디에서나 접근 가능
 지역 스코프 -지역 변수 ; 변수를 선언한 함수 내부에서만 접근 가능 / 반복문이나 조건문 같이 블록 내부 선언도 지역,,
 ->블록기준으로 지역 스코프 정함 ; 블록 스코프
 함수 스코프 -> var키워드로 선언 
 -> 블록 내부 선언했으나 블록 외부에서 접근 가능

객체
->원시 자료형과 달리 다양한 값 저장
->객체 생성 1.리터럴 2.생성자
*프로퍼티 : 속성 / 객체 설명하는 정보
*객체는 key, value로 이루어진 프로퍼티의 모음
 객체에서 모든 연산은 key 이용
객체에서 값이 함수인 프로퍼티 = 메서드

배열
->순서가 있는 요소의 집합이자 여러 개의 항목을 담는 리스트
-> 생성 1.생성자 2.리터럴
->객체에서 key 역할이 배열에서 인덱스

truthy&falsy
-> 불리언 자료형의 참이나 거짓이 아닌 값도 상황에 따라 참 거짓으로 판단

단락평가
->논리 연산에서 첫 번째 피연산자의 값만으로 해당 식이 결과가 확실할 때, 두 번째 값은 평가하지 않는 것
** AND -> 하나라도 거짓이면 거짓 / OR -> 하나라도 참이면 참 

객체 자료형
->

반복문 응용
-> 배열과 반복문 / 객체와 반복문
